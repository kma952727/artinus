# run
server run command : `docker-compose up --build backend` </br>
test command : `./gradlew test` </br>
api 문서 : http://localhost:8080/swagger-ui/index.html#/

<br>

참조 
1. resources/data.sql에 더미데이터를 넣어두었습니다.
2. db는 도커 compose로 바로 올라갈 수 있게 구성해두었습니다.

# 아키텍쳐
주요 기술 : Java21, SpringBoot3, Jpa3, Junit5, Mysql8, Docker, 단일 모듈, layered 구조

### 코드 작성에 고려한 것
1. 엔티티의 상태를 변경시키는 커맨드 작업은 Entity 클래스 내부에 위치시켰습니다. 위험도가 높은 로직이 응집되어 있다는 점에서<br>
 코드 리뷰시에도 도움이 되고 스프링같은 외부 라이브러리, 프레임워크를 참조하지 않으므로 테스트 코드 작성 난이도도 줄어듭니다.
2. 구독 이력 생성은 이벤트 개념을 적용했습니다. 제일 주요한 것은 "사용자가 구독하는 것"이라고 생각합니다. 구독 이력 생성 실패가 사용자의 구독까지 실패시키는 것은 좋지 않다고 생각합니다.
3. 재활용 가능성이 높을 것 같은 기능들은 `xxBaseService`에 작성됩니다. 엔티티를 조회했는데 null이라면 예외를 던지는 기능같은 것이 작성됩니다.

### 테스트 코드 작성에 고려한 것
1. 테스트 코드는 서비스 레이어와 엔티티만 작성했습니다. 전반적으로 로직을 쿼리에서 코드단으로 끌고왔기 때문에 리파지토리 레이어에는 단순한 로직들이 남았습니다. 
게다가 서비스 레이어 테스트(모킹 X)로 리자피토리도 함께 테스트되기 때문에 리파지토리는 테스트 코드를 작성하지 않습니다.
2. 서비스레이어 테스트마다 중복으로 작성되는 코드(어노테이션 선언, 빈 참조, ...)들은 `ServiceLayerTestTemplate` 추상 클래스에 선언하여 테스트 가독성, 효율성을 높혔습니다.


# 비즈니스 분석
구독 개념을 사용하는 서비스를 검색했을 때 구독/해지를 할 수 있는 채널(KT, 콜센터, ..)이 존재하고 채널에서 제공하는 플랜들이 이루어지는 구조로 보여집니다.

```
밀리의 서재 서비스 기준으로 LGU 채널에서 "밀리의 서재 1개월 구독" 플랜을 제공, KTM 채널에서 "모두다 맘껏7GB+(무제한 구독)", "모두다 맘껏10GB+(무제한 구독)" 플랜들을 제공
```
고로 [ `사용자` <- 1:1 -> `구독` <- 1:N -> `채널` <- 1:N -> `플랜` ] 처럼 엔티티 관계를 설정하여 기능을 작성했습니다.  <br>
구독 상태는 플랜에 종속되는게 어울린다고 판단하여 구독하기/구독해지 API에서 구독 상태는 받지 않도록 하고 채널의 기본 플랜을 참조하도록 자의적으로 해석하여 구현하였습니다.